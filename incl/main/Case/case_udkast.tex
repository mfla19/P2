\chapter{Case}
Teorien omkring store-M metoden vil nu blive anvendt til optimeringen af en specifik case. Problemet som skal optimeres er tildelingen af arbejdsopgaver til ansatte i en virksomhed. I denne case har de ansatte forskellig løn, maks antal timer, samt forskellige effektiviteter i løsningen af de forskellige opgaver. Yderligere har hver oppgave et antal gange som de skal løses. Optimeringsproblemet handler herudfra om at minimere firmaets udgifter til løn. Netop store-M metoden anvendes, da problemet ikke har en åbenlys basisløsning og da problemet herved kan løses med et enkelt optimeringsproblem.

Lad en virksomhed have $M$ ansatte, hvor den $i$'te ansatte maksimalt må arbejde $T_i$ timer, hvor $i=1,...,M$. Virksomheden har $N$ arbejdsopgaver, som hver skal løses $O_j$ gange, hvor $j=1,...,N$.
Herom gælder det at $p_{ij}$ er mængden af tid den $i$'te ansatte bruger på den $j$'te opgave, hvilket den ansatte gør med en effektiviteten $n_{ij}$. Derudover har hver ansatte en individuel løn $L_i$.
For dette problem gælder det om at minimere udgifterne til løn. Dette kan alt sammen ses i følgende programmeringsproblem, som søger at minimere udgifterne:

\begin{center}
	\begin{tabular}{l	>{$}l<{$}}
Minimer			&\sum_{i=1}^M L_i \left( \sum_{j=1}^N p_{ij} \right)\\
\rule{0pt}{4ex}Med hensyn til 	&T_i \geq \sum_{j=1}^N p_{ij}\\
				&O_{j} = \sum_{i=1}^M n_{ij} p_{ij}\\
og $p_{ij} \geq 0.$
	\end{tabular}
\end{center}

Ved anvendelse af store M metoden til løsningen af dette problem skal der anvendes slack-variable og kunstige variable. Enhver ulighed skal omskrives til en lighed, hvilket kræver indførslen af en slack-variabel. For begrænsninger som begænser en persons timetal vil disse kunne omskrives til:
$$T_i = \sum_{j=1}^N p_{ij}+s_i$$
I store M metoden kræver denne begrænsning ikke en ekstra variabel med cost M, da $s_i$ gerne må eksistere i den endelige løsning.

Begrænsninger af typen
$O_{j} = \sum_{i=1}^M n_{ij} p_{ij},$
kræver en ekstra variabel $a_j$ med cost M, for at kunne danne en begyndende basisløsning. Derved omskrives disse begrænsninger til
$$O_{j} = \sum_{i=1}^M n_{ij} p_{ij}+a_j$$

Derved kan problemet omskrives til:
\begin{center}
	\begin{tabular}{l	>{$}l<{$}}
Minimer			&\sum_{i=1}^M L_i \left( \sum_{j=1}^N p_{ij} \right)+M\sum_{j=1}^N a_j\\
\rule{0pt}{4ex}Med hensyn til 	&T_i = \sum_{j=1}^N p_{ij} + s_i\\
				&O_{j} = \sum_{i=1}^M n_{ij} p_{ij}+a_j\\
og $p_{ij} \geq 0.$
	\end{tabular}
\end{center}

Der vil derved være $M \cdot N$ variable $p_{ij}$, $M$ slack-variable $s_i$, og $N$ kunstige variable $a_j$. Dette giver i alt $M \cdot N+M+N$ variable i $M+N$ begrænsninger. Ved konstruktionen af den fulde tabel tilføjes endnu en række og søjle. Derved får tabellen størrelse $M+N+1 \times M\cdot N+M+N+1$. 
Løsningsvektoren og cost vektoren bliver derved:

\begin{align*}
\vec{x}^T=\rvect{p_{11} ... p_{1N} & ... & p_{M1} ... p_{MN} & s_1 ... s_M & a_1 ... a_N}.
\end{align*}
\begin{align*}
\vec{c}^T=\kbordermatrix{
& \times N & & \times N & \times M & \times N \\
&L_1 ... L_1 & ... & L_M...L_M & 0...0 & M...M
},
\end{align*}
hvor f.eks. $\times N$ betyder at indgang udgør $N$ indgange af vektoren.

Ved introduktionen af slack-variable og kunstige variable, kan disse derved udgøre den første basis for ligningssystemet. Derved bliver basisindeks og basisvektor til:
\begin{align*}
&\vec{I}_B^T=\rvect{s_1 ... s_M & a_1 ... a_N}\\
&\vec{x}_B^T=\rvect{T_1 ... T_M & O_1 ... O_N},
\end{align*}
da $p_{ij}=0$ for $i=1,2,...,M$ og $j=1,2,...,N$, og da leddene $s_i$ og $a_j$ derved er de eneste ikke-nul led i betingelserne.


Betingelserne indskrives da i matricen $A$ i rækkefølgen dikteret af basisindeks. For et problem med $M=2$ og $N=3$ gælder det derved at
\begin{align*}
B^{-1}A=\kbordermatrix{
&p_{11} & p_{12} & p_{13} & p_{21} & p_{22} & p_{23} & s_1 & s_2 & a_1 & a_2 & a_3\\
&1       & 1      & 1      & 0      & 0      & 0      & 1 & 0 & 0 & 0 & 0 \\
&0       & 0      & 0      & 1      & 1      & 1      & 0 & 1 & 0 & 0 & 0 \\
&n_{11}  & 0      & 0      & n_{21} & 0      & 0      & 0 & 0 & 1 & 0 & 0 \\
&0       & n_{12} & 0      & 0      & n_{22} & 0      & 0 & 0 & 0 & 1 & 0 \\
&0       & 0      & n_{13} & 0      & 0      & n_{23} & 0 & 0 & 0 & 0 & 1
}_,
\end{align*}
da $B^{-1}=B=I_{M+N}$ og da det derved gælder at $B^{-1}A=I_{M+N}A=A$.

\section{Løsning af problemet}
Når den fulde tabel er sat op for problemet ligesom i fuld tabel vil den kunne løses ligesom med fuld tabel metoden.
For netop denne case er der nogle faktorer, som betyder at problemet bliver simplificeret lidt.
Da alle indgange i $B^{-1}$ og $\vec{x}_B$ er positive, vil alle rækker ifølge Sætning \ref{stn:lexi} forblive lexi-positive. Hvorved der ikke er brug for at bytte om på søjlerne.
Da der findes en unik variabel i hver betingelse, garanterer dette at rækkerne er lineært uafhængige, hvorved de fundne basisløsninger har dimension 1. Derved er det ikke nødvendigt at tage højde for eventuelle tilfælde med lineært afhængige rækker. Derved er det udelukkende nødvendigt at undersøge 3 scenariar: 
\begin{itemize}
\item problemet har en endelig mindste cost. \item problemet har en uendeligt lav mindste cost.
\item problemet har ingen løsning.
\end{itemize}

\newpage

\begin{alg}[label={alg:lexi}]{Lexi pivot algoritme}
def $\textbf{lexi}$(A,piv_søjle):
	minrække = [rækker i $I_B$ for hvilke A[række][pivot søjle] > 0]
	Hvis len(minrække) == 0:
		returner -1 #Uendeligt lav cost
	for søjle i range(len(A[0])):
		$\theta$ = [$\frac{x_{B(i)}}{u_i}$ for række i minrække]
		minrække = [rækker i minrække for hvilke $\theta$[række] = min($\theta$)]
		hvis længde af minrække == 1:
			returner minrække[0] #række fundet og returneres

\end{alg}


\begin{alg}[label={alg:storem2}]{Store-M algoritmen}
def $\textbf{storeM}$(A,I_B):
    while true: #kører iterationer indtil løsning fundet
    	for i in range(1,len(A[0])): 
        	if A[0][i] < 0: # finder søjle med ${\color{commentgreen} \overline{c}_i}$<0
            	piv_søjle = i
        	elif i == len(A[0])-1: #hvis ingen reduceret cost er negative så afsluttes
				break
            
    	L,minrække=$\textbf{lexi}$(A,piv_søjle) #finder den lexi-mindste række
    	if L == -1: #uendeligt lav cost,
			break
            
    	piv_punkt = A[L][piv_søjle] 
    	for søjle in range(len(A[0])): #dividerer piv række med piv punkt
        	A[L][søjle] /= piv_punkt
            
    	for række in range(len(A)): #trækker piv række fra andre rækker
        	if række != L:
            	række_trækfra = A[række][piv_søjle]
            	for søjle in range(len(A[0])):
                	A[række][søjle] -= række_trækfra*A[L][søjle]

    	I_B[L-1]=piv_søjle #ny variabel indsættes i indeks for basis

	for indeks in $I_B$: 
		if indeks > M*N+M: #kunstige variable stadig i basis. Ingen mulig løsning fundet
			cost = $\infty$
	if L == -1: # uendeligt lav cost
		cost = $-\infty$
	else: #løsning fundet
		cost = $-A[0][0]$
\end{alg}

\begin{eks}[Case eksempel]
Lad en virksomhed have 5 medarbejdere, som skal have udført 4 opgaver og lad parametrene være givet som:
\end{eks}